// Code generated by Protoconf (https://version.uuzu.com/Merlion/protoconf). DO NOT EDIT.
// Code generated at 23 May 19 17:49 DST, with protoconf version 0.2.0
// This code is designed to work with protoconf-go (https://github.com/yoozoo/protoconf-go) v1.0

package prometheus

import (
	"errors"
	"strconv"
	"strings"

	protoconfGo "github.com/yoozoo/protoconf_go"
)

type watchListener func(string)

type watchKeyInterface interface {
	watchKey(k string, l watchListener)
}

type Config struct {
	address     string
	app_configs map[string]*AppConfig

	_keys      []string
	_watchList map[string]watchListener
	_prefix    string
}

var _ protoconfGo.Configuration = (*Config)(nil)

// make sure strconv is used
var _, _ = strconv.Atoi("-42")

func newConfig() *Config {
	p := new(Config)
	p.app_configs = make(map[string]*AppConfig)
	p._keys = []string{
		"address",
		"app_configs/MAP_ENTRY/app_name",
		"app_configs/MAP_ENTRY/metrics/MAP_ENTRY/metric_name",
		"app_configs/MAP_ENTRY/metrics/MAP_ENTRY/metric_type",
		"app_configs/MAP_ENTRY/metrics/MAP_ENTRY/regex",
	}
	p._watchList = make(map[string]watchListener)
	return p
}

var instance *Config = newConfig()

func GetInstance() *Config {
	return instance
}

func (p *Config) ApplicationName() string {
	return "北美平台-gogstash"
}

func (p *Config) ValidKeys() []string {
	return p._keys
}

func (p *Config) watchKey(key string, listener watchListener) {
	p._watchList[key] = listener
}

func (p *Config) NotifyValueChange(key string, value string) {
	listener, ok := p._watchList[key]
	if ok {
		listener(value)
		p.SetValue(key, value)
	}
}

func (p *Config) GetAddress() string {
	return p.address
}
func (p *Config) GetApp_configs() map[string]*AppConfig {
	return p.app_configs
}

func (p *Config) DefaultValue(key string) *string {
	switch key {
	case "address":
		tmp := "8080"
		return &tmp
	default:
		keys := strings.SplitN(key, "/", 2)
		if len(keys) >= 2 {
			newKey := keys[0]
			switch newKey {
			case "app_configs":
				keys = strings.SplitN(keys[1], "/", 2)
				if len(keys) >= 2 {
					if obj, ok := p.app_configs[keys[0]]; ok {
						return obj.DefaultValue(keys[1])
					}
				}
			}
		}
	}
	return nil
}

func (p *Config) SetValue(key string, value string) error {
	switch key {
	case "address":
		p.address = value
		return nil
	default:
		keys := strings.SplitN(key, "/", 2)
		if len(keys) >= 2 {
			newKey := keys[0]
			switch newKey {
			case "app_configs":
				keys = strings.SplitN(keys[1], "/", 2)
				if len(keys) >= 2 {
					obj, ok := p.app_configs[keys[0]]
					if !ok {
						obj = NewAppConfig(p, p._prefix+"app_configs/"+keys[0])
						p.app_configs[keys[0]] = obj
					}
					return obj.SetValue(keys[1], value)
				}
			}
		}
	}
	return errors.New("Unknown key:" + key)
}

type Metric struct {
	regex       string
	metric_type int64
	metric_name string

	_parent watchKeyInterface
	_prefix string
}

func NewMetric(parent watchKeyInterface, prefix string) *Metric {
	p := new(Metric)

	p._parent = parent
	p._prefix = prefix + "/"

	return p
}

func (p *Metric) watchKey(key string, l watchListener) {
	p._parent.watchKey(p._prefix+"/"+key, l)
}

func (p *Metric) GetRegex() string {
	return p.regex
}
func (p *Metric) GetMetric_type() int64 {
	return p.metric_type
}
func (p *Metric) GetMetric_name() string {
	return p.metric_name
}

func (p *Metric) DefaultValue(key string) *string {
	switch key {
	case "regex":
		tmp := "*"
		return &tmp
	case "metric_type":
		tmp := "0"
		return &tmp
	case "metric_name":
		tmp := "metric"
		return &tmp
	default:
		keys := strings.SplitN(key, "/", 2)
		if len(keys) >= 2 {
			newKey := keys[0]
			switch newKey {
			}
		}
	}
	return nil
}

func (p *Metric) SetValue(key string, value string) error {
	switch key {
	case "regex":
		p.regex = value
		return nil
	case "metric_type":
		tmp, err := strconv.ParseInt(value, 10, 64)
		if err != nil {
			return err
		}
		p.metric_type = tmp
		return nil
	case "metric_name":
		p.metric_name = value
		return nil
	default:
		keys := strings.SplitN(key, "/", 2)
		if len(keys) >= 2 {
			newKey := keys[0]
			switch newKey {
			}
		}
	}
	return errors.New("Unknown key:" + key)
}

type AppConfig struct {
	app_name string
	metrics  map[string]*Metric

	_parent watchKeyInterface
	_prefix string
}

func NewAppConfig(parent watchKeyInterface, prefix string) *AppConfig {
	p := new(AppConfig)

	p._parent = parent
	p._prefix = prefix + "/"
	p.metrics = make(map[string]*Metric)

	return p
}

func (p *AppConfig) watchKey(key string, l watchListener) {
	p._parent.watchKey(p._prefix+"/"+key, l)
}

func (p *AppConfig) GetApp_name() string {
	return p.app_name
}
func (p *AppConfig) GetMetrics() map[string]*Metric {
	return p.metrics
}

func (p *AppConfig) DefaultValue(key string) *string {
	switch key {
	case "app_name":
		tmp := "app"
		return &tmp
	default:
		keys := strings.SplitN(key, "/", 2)
		if len(keys) >= 2 {
			newKey := keys[0]
			switch newKey {
			case "metrics":
				keys = strings.SplitN(keys[1], "/", 2)
				if len(keys) >= 2 {
					if obj, ok := p.metrics[keys[0]]; ok {
						return obj.DefaultValue(keys[1])
					}
				}
			}
		}
	}
	return nil
}

func (p *AppConfig) SetValue(key string, value string) error {
	switch key {
	case "app_name":
		p.app_name = value
		return nil
	default:
		keys := strings.SplitN(key, "/", 2)
		if len(keys) >= 2 {
			newKey := keys[0]
			switch newKey {
			case "metrics":
				keys = strings.SplitN(keys[1], "/", 2)
				if len(keys) >= 2 {
					obj, ok := p.metrics[keys[0]]
					if !ok {
						obj = NewMetric(p, p._prefix+"metrics/"+keys[0])
						p.metrics[keys[0]] = obj
					}
					return obj.SetValue(keys[1], value)
				}
			}
		}
	}
	return errors.New("Unknown key:" + key)
}
